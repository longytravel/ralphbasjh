"""Step 8: Parse Optimization Results (Pass 1 - Wide).

This step parses the XML output from Step 7 optimization and filters
valid passes that meet minimum trade requirements.

Per PRD Section 3, Step 8:
- Gate: valid_passes >= 1
- Minimum trades: ONTESTER_MIN_TRADES (default: 10)
- Forward merge: if _fwd.xml exists, merge forward metrics
- Output: pass1_results for Stat Explorer and LLM analysis
"""

from dataclasses import dataclass, field, asdict
from pathlib import Path
from typing import List, Optional, Dict, Any

from ...mt5.parser import MT5XMLParser, OptimizationPass, parse_optimization_xml
from ...config import ONTESTER_MIN_TRADES


@dataclass
class ParseResult:
    """Result of parsing optimization XML."""
    success: bool
    xml_path: Path
    valid_passes: int
    total_passes: int
    passes: List[Dict[str, Any]] = field(default_factory=list)

    # Gate tracking
    gate_passed: bool = False

    # Metadata
    min_trades_threshold: int = ONTESTER_MIN_TRADES
    forward_merged: bool = False
    forward_xml_path: Optional[Path] = None
    error_message: Optional[str] = None

    def passed_gate(self) -> bool:
        """Check if gate passed: valid_passes >= 1."""
        return self.valid_passes >= 1

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            "success": self.success,
            "xml_path": str(self.xml_path),
            "valid_passes": self.valid_passes,
            "total_passes": self.total_passes,
            "passes": self.passes,
            "gate_passed": self.gate_passed,
            "min_trades_threshold": self.min_trades_threshold,
            "forward_merged": self.forward_merged,
            "forward_xml_path": str(self.forward_xml_path) if self.forward_xml_path else None,
            "error_message": self.error_message
        }


def _optimization_pass_to_dict(opt_pass: OptimizationPass) -> Dict[str, Any]:
    """Convert OptimizationPass to dictionary.

    Follows PRD Section 6.3 Pass Format with separate back/forward metrics.

    Args:
        opt_pass: OptimizationPass object

    Returns:
        Dictionary representation matching PRD format
    """
    # Build back metrics
    back_metrics = {
        "profit": opt_pass.profit,
        "profit_factor": opt_pass.profit_factor,
        "total_trades": opt_pass.total_trades,
        "max_drawdown_pct": opt_pass.max_drawdown_pct,
        "win_rate": opt_pass.win_rate,
        "sharpe_ratio": opt_pass.sharpe_ratio,
        "expected_payoff": opt_pass.expected_payoff,
        "recovery_factor": opt_pass.recovery_factor
    }

    # Build forward metrics (if available)
    forward_metrics = None
    if opt_pass.forward_profit is not None:
        forward_metrics = {
            "profit": opt_pass.forward_profit,
            "profit_factor": opt_pass.forward_profit_factor or 0.0,
            "total_trades": opt_pass.forward_total_trades or 0,
            "max_drawdown_pct": opt_pass.forward_drawdown_pct or 0.0,
            "win_rate": opt_pass.forward_win_rate or 0.0
        }

    # Build parameters dict (include Pass number and Back/Forward Result)
    params = {
        "Pass": opt_pass.pass_number,
        **opt_pass.parameters,
        "Back Result": opt_pass.result
    }
    if opt_pass.forward_profit is not None:
        params["Forward Result"] = opt_pass.forward_profit

    # Build final dict per PRD Section 6.3
    result = {
        "result": opt_pass.result,
        "profit": opt_pass.profit,
        "profit_factor": opt_pass.profit_factor,
        "max_drawdown_pct": opt_pass.max_drawdown_pct,
        "total_trades": opt_pass.total_trades,
        "win_rate": opt_pass.win_rate,
        "sharpe_ratio": opt_pass.sharpe_ratio,
        "expected_payoff": opt_pass.expected_payoff,
        "recovery_factor": opt_pass.recovery_factor,
        "source": "pass1",
        "back": back_metrics,
        "params": params
    }

    # Add forward metrics if available
    if forward_metrics:
        result["forward"] = forward_metrics

    return result


def parse_optimization_results(
    xml_path: Path,
    min_trades: Optional[int] = None,
    forward_xml_path: Optional[Path] = None
) -> ParseResult:
    """Parse optimization results from XML file.

    This is Step 8 in the workflow. It parses the optimization XML
    generated by Step 7 and filters passes by minimum trade count.

    Args:
        xml_path: Path to optimization XML file from Step 7
        min_trades: Minimum trades threshold (default: ONTESTER_MIN_TRADES from config)
        forward_xml_path: Optional path to forward period XML (_fwd.xml)

    Returns:
        ParseResult with success status and parsed passes

    Example:
        >>> result = parse_optimization_results(
        ...     Path("runs/reports/workflow_123/MyEA_S6_opt1_EURUSD_H1_abc12345.xml"),
        ...     min_trades=10
        ... )
        >>> if result.passed_gate():
        ...     print(f"Found {result.valid_passes} valid passes")
    """
    if min_trades is None:
        min_trades = ONTESTER_MIN_TRADES

    xml_path = Path(xml_path)

    # Check if XML file exists
    if not xml_path.exists():
        return ParseResult(
            success=False,
            xml_path=xml_path,
            valid_passes=0,
            total_passes=0,
            gate_passed=False,
            min_trades_threshold=min_trades,
            error_message=f"XML file not found: {xml_path}"
        )

    try:
        # Parse optimization results with minimum trades filter
        parser = MT5XMLParser(xml_path)
        passes = parser.parse_optimization_results(min_trades=min_trades)

        # Check for forward XML and merge if exists
        forward_merged = False
        actual_forward_path = None

        if forward_xml_path and forward_xml_path.exists():
            passes = parser.merge_forward_metrics(passes, forward_xml_path)
            forward_merged = True
            actual_forward_path = forward_xml_path
        else:
            # Try to auto-detect forward XML (same name with _fwd suffix)
            auto_forward_path = xml_path.parent / f"{xml_path.stem}_fwd.xml"
            if auto_forward_path.exists():
                passes = parser.merge_forward_metrics(passes, auto_forward_path)
                forward_merged = True
                actual_forward_path = auto_forward_path

        # Convert OptimizationPass objects to dicts for JSON serialization
        passes_dicts = [_optimization_pass_to_dict(p) for p in passes]

        # Count total passes (including those filtered out)
        # We need to parse again without min_trades filter to get total count
        all_passes = parser.parse_optimization_results(min_trades=0)
        total_passes = len(all_passes)
        valid_passes = len(passes)

        gate_passed = valid_passes >= 1

        return ParseResult(
            success=True,
            xml_path=xml_path,
            valid_passes=valid_passes,
            total_passes=total_passes,
            passes=passes_dicts,
            gate_passed=gate_passed,
            min_trades_threshold=min_trades,
            forward_merged=forward_merged,
            forward_xml_path=actual_forward_path
        )

    except Exception as e:
        return ParseResult(
            success=False,
            xml_path=xml_path,
            valid_passes=0,
            total_passes=0,
            gate_passed=False,
            min_trades_threshold=min_trades,
            error_message=f"Failed to parse optimization XML: {str(e)}"
        )


def validate_parse_results(
    xml_path: Path,
    min_trades: Optional[int] = None
) -> ParseResult:
    """Convenience function for parse_optimization_results.

    Args:
        xml_path: Path to optimization XML file
        min_trades: Minimum trades threshold

    Returns:
        ParseResult
    """
    return parse_optimization_results(xml_path, min_trades=min_trades)
